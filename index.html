<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cesta za p√≠smenky</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Times New Roman', Times, serif;
            touch-action: manipulation;
            background-color: #f0fdf4; /* emerald-50 */
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23a7f3d0' fill-opacity='0.4'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }
        
        #board-container {
            position: relative;
            width: 100%;
            max-width: 900px;
            aspect-ratio: 1 / 1.2;
            margin: auto;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 5px;
        }

        @media (min-width: 768px) {
            #board-container {
                aspect-ratio: 2 / 1;
                gap: 10px;
            }
        }

        .tile {
            position: relative;
            width: 100%;
            height: 100%; /* Will be controlled by container height to keep squares */
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1), inset 0 2px 4px rgba(255,255,255,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            border: 2px solid rgba(255,255,255,0.7);
            transition: transform 0.2s ease;
        }
        .tile:hover {
            transform: scale(1.05);
        }

        .tile-number {
            position: absolute;
            top: 2px;
            left: 6px;
            font-size: clamp(0.6rem, 1.5vw, 0.9rem);
            color: rgba(0,0,0,0.4);
        }
        .tile-content {
            font-size: clamp(1rem, 4vw, 2rem);
        }

        .tile[data-tile-id="1"] { grid-area: 1 / 1; }
        .tile[data-tile-id="2"] { grid-area: 1 / 2; }
        .tile[data-tile-id="3"] { grid-area: 1 / 3; }
        .tile[data-tile-id="4"] { grid-area: 1 / 4; }
        .tile[data-tile-id="5"] { grid-area: 1 / 5; }
        .tile[data-tile-id="6"] { grid-area: 1 / 6; }
        .tile[data-tile-id="7"] { grid-area: 1 / 7; }
        .tile[data-tile-id="8"] { grid-area: 1 / 8; }
        
        .tile[data-tile-id="16"] { grid-area: 2 / 1; }
        .tile[data-tile-id="15"] { grid-area: 2 / 2; }
        .tile[data-tile-id="14"] { grid-area: 2 / 3; }
        .tile[data-tile-id="13"] { grid-area: 2 / 4; }
        .tile[data-tile-id="12"] { grid-area: 2 / 5; }
        .tile[data-tile-id="11"] { grid-area: 2 / 6; }
        .tile[data-tile-id="10"] { grid-area: 2 / 7; }
        .tile[data-tile-id="9"] { grid-area: 2 / 8; }

        .tile[data-tile-id="17"] { grid-area: 3 / 1; }
        .tile[data-tile-id="18"] { grid-area: 3 / 2; }
        .tile[data-tile-id="19"] { grid-area: 3 / 3; }
        .tile[data-tile-id="20"] { grid-area: 3 / 4; }
        .tile[data-tile-id="21"] { grid-area: 3 / 5; }
        .tile[data-tile-id="22"] { grid-area: 3 / 6; }
        .tile[data-tile-id="23"] { grid-area: 3 / 7; }
        .tile[data-tile-id="24"] { grid-area: 3 / 8; }

        .tile[data-tile-id="32"] { grid-area: 4 / 1; }
        .tile[data-tile-id="31"] { grid-area: 4 / 2; }
        .tile[data-tile-id="30"] { grid-area: 4 / 3; }
        .tile[data-tile-id="29"] { grid-area: 4 / 4; }
        .tile[data-tile-id="28"] { grid-area: 4 / 5; }
        .tile[data-tile-id="27"] { grid-area: 4 / 6; }
        .tile[data-tile-id="26"] { grid-area: 4 / 7; }
        .tile[data-tile-id="25"] { grid-area: 4 / 8; }
        
        .tile.start { background-color: #2dd4bf !important; color: white; }
        .tile.end { background-color: #2dd4bf !important; color: white; }
        .tile.malice { background-color: #c084fc; } /* purple-400 */

        .player {
            position: absolute;
            transition: all 0.5s ease-in-out;
            z-index: 10;
        }
        .player svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.3));
        }

        .dice { cursor: pointer; transition: transform 0.3s ease; }
        .dice:hover { transform: scale(1.05); }
        .dice.disabled { cursor: not-allowed; opacity: 0.5; }
        .dice.rolling { animation: roll 0.7s ease-in-out; }
        @keyframes roll {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(360deg) scale(1.2); }
            100% { transform: rotate(720deg) scale(1); }
        }
        .modal, #setup-screen { animation: fadeIn 0.5s ease; }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .modal { max-height: 90vh; overflow-y: auto; -webkit-overflow-scrolling: touch; }
        input[type="color"] {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            width: 44px; height: 44px; background-color: transparent; border: none; cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch { border-radius: 50%; border: 2px solid #e5e7eb; }
        input[type="color"]::-moz-color-swatch { border-radius: 50%; border: 2px solid #e5e7eb; }
        .shape-btn, .player-count-btn {
            width: 40px; height: 40px; cursor: pointer; border: 3px solid transparent;
            transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;
            background-color: #e5e7eb; border-radius: 8px; font-weight: bold;
        }
        .shape-btn.selected, .player-count-btn.selected { border-color: #0d9488; background-color: #ccfbf1; }
        .shape-btn svg { width: 24px; height: 24px; fill: #4b5563; }
        .malice-card-btn {
            background-color: #a855f7; color: white; padding: 8px 12px; border-radius: 9999px;
            font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: all 0.2s ease;
        }
        .malice-card-btn:hover { background-color: #9333ea; transform: translateY(-2px); }
        .malice-card-btn:disabled { background-color: #d8b4fe; cursor: not-allowed; transform: none; }
        /* Odstranƒõno: styly pro skl√°d√°n√≠ slov (.letter-tile, .answer-slot) nejsou ji≈æ pot≈ôeba */

        /* ================= MOBILE FRIENDLY ENHANCEMENTS ================= */
        @media (max-width: 640px) {
            body { padding: 0.5rem; }
            h1 { font-size: clamp(1.75rem, 9vw, 2.6rem) !important; }
            #game-panel { flex-direction: column; padding: 0.5rem; }
            #message-log { height: 64px; font-size: 0.9rem; }
            #dice-container { width: 72px; height: 72px; }
            #dice { font-size: 3rem; }
            .tile { border-radius: 10px; }
            .tile-number { font-size: clamp(0.55rem, 2.2vw, 0.75rem); }
            .tile-content { font-size: clamp(0.9rem, 4.5vw, 1.6rem); }
            #setup-screen { padding: 1.25rem; }
            .shape-btn, .player-count-btn { width: 44px; height: 44px; }
            .malice-card-btn { padding: 6px 10px; font-size: 0.75rem; }
            #board-container { aspect-ratio: 1 / 1; max-width: 100%; }
            #modal-backdrop { padding: 0.75rem; }
        }
        @media (max-width: 400px) {
            h1 { font-size: clamp(1.6rem, 10vw, 2.2rem) !important; }
            #dice-container { width: 64px; height: 64px; }
            #dice { font-size: 2.5rem; }
        }

        /* Landscape small height handling */
        @media (max-height: 500px) and (orientation: landscape) {
            #game-panel { flex-direction: row; }
            #board-container { aspect-ratio: 1 / 0.85; }
            .modal { max-height: 85vh; }
        }
        /* Floating dice on very small devices for easier reach */
        @media (max-width: 640px) {
            #dice-container.floating { position: fixed; bottom: 0.75rem; right: 0.75rem; z-index: 40; box-shadow: 0 4px 12px rgba(0,0,0,0.25); }
        }
        /* ================= END MOBILE ENHANCEMENTS ================= */

        /* ============== MOBILE LANDSCAPE FULLSCREEN MODE ============== */
        body.landscape-compact, html.landscape-compact {
            padding: 0 !important;
            margin: 0 !important;
            height: 100%;
            overflow: hidden;
            touch-action: manipulation;
        }
        body.landscape-compact #game-container {
            max-width: 100vw;
            width: 100vw;
            margin: 0;
        }
        body.landscape-compact #game-panel {
            position: absolute;
            top: 0; left: 0; right: 0;
            backdrop-filter: blur(8px);
            background: rgba(255,255,255,0.65);
            z-index: 25;
            padding: 4px 8px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        body.landscape-compact #game-panel.panel-condensed {
            padding: 2px 4px;
            gap: 2px;
            background: rgba(255,255,255,0.55);
        }
        body.landscape-compact #game-panel.panel-condensed #turn-indicator { font-size: 0.85rem; margin-bottom: 0; }
        body.landscape-compact #game-panel.panel-condensed #message-log { height: 44px; font-size: 0.7rem; padding: 2px 4px; }
        body.landscape-compact #game-panel.panel-condensed #dice-container { width: 56px; height: 56px; }
        body.landscape-compact #game-panel.panel-condensed #dice { font-size: 2rem; }
        body.landscape-compact #game-panel.panel-condensed .malice-card-btn { padding: 2px 6px; font-size: 0.6rem; }
        body.landscape-compact #game-panel.panel-condensed #panel-toggle-btn { padding: 2px 4px; font-size: 0.65rem; }
        body.landscape-compact #game-panel #message-log { height: 56px; }
        body.landscape-compact h1 { display:none; }
        body.landscape-compact #board-container {
            position: absolute;
            left: 0; right: 0; bottom: 0;
            margin: 0 auto;
            /* top will be set dynamically based on panel height to avoid scroll */
        }
        body.landscape-compact #game-stage { position: relative; }
        body.landscape-compact #dice-container.floating { bottom: 0.5rem; }
        /* Toggle button for collapsing panel (optional style) */
        body.landscape-compact #panel-toggle-btn { display:inline-flex; }
        #panel-toggle-btn { display:none; }
        body.landscape-compact .panel-collapsed #game-panel { transform: translateY(-100%); }
        body.landscape-compact .panel-collapsed #board-container { top: 8px; }
        /* ============== END MOBILE LANDSCAPE FULLSCREEN MODE ============== */
    </style>
</head>
<body class=" text-gray-800 flex flex-col items-center justify-center min-h-screen p-2 sm:p-4">

    <!-- √övodn√≠ obrazovka -->
    <div id="setup-screen" class="w-full max-w-lg mx-auto p-6 bg-white/80 backdrop-blur-sm rounded-2xl shadow-lg">
        <h1 class="text-4xl md:text-5xl font-bold text-center text-emerald-700 mb-6">Nastaven√≠ hry</h1>
        <div class="mb-6">
            <p class="text-xl font-bold text-gray-700 mb-2 text-center">Poƒçet hr√°ƒç≈Ø</p>
            <div id="player-count-selector" class="flex justify-center space-x-2">
                <button class="player-count-btn selected" data-count="2">2</button>
                <button class="player-count-btn" data-count="3">3</button>
                <button class="player-count-btn" data-count="4">4</button>
            </div>
        </div>
        <div id="player-setups-container" class="space-y-4"></div>
        <div class="mt-6 flex flex-col space-y-4">
            <button id="sentence-settings-btn" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-full text-lg shadow-md transform hover:scale-105 transition-transform">Nastaven√≠ fr√°z√≠</button>
            <button id="start-game-btn" class="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-4 px-8 rounded-full text-2xl shadow-lg transform hover:scale-105 transition-transform">Hr√°t!</button>
        </div>
    </div>

    <!-- Hern√≠ obrazovka -->
    <div id="game-container" class="w-full max-w-5xl mx-auto hidden">
        <h1 class="text-4xl md:text-6xl font-bold text-center text-emerald-700 mb-4 md:mb-6" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.1);">Cesta za p√≠smenky</h1>
        <div id="game-stage" class="relative">
            <div id="game-panel" class="flex flex-col md:flex-row items-center justify-between bg-white/70 backdrop-blur-sm rounded-2xl shadow-lg p-2 md:p-4 mb-4 md:mb-6">
                <button id="panel-toggle-btn" title="Skr√Ωt / zobrazit panel" class="mr-2 bg-emerald-500 hover:bg-emerald-600 text-white font-bold px-3 py-2 rounded-lg shadow transition-transform active:scale-95 hidden">‚¨ÜÔ∏è</button>
                <div class="flex-1 flex flex-col items-center md:items-start">
                    <div id="turn-indicator" class="text-xl md:text-2xl font-bold mb-2 text-center"></div>
                    <div id="malice-cards-container" class="flex flex-wrap gap-2 h-12 items-center"></div>
                </div>
                <div class="flex items-center justify-between w-full md:w-auto md:space-x-4 mt-2 md:mt-0">
                     <div id="message-log" class="text-base md:text-lg text-gray-600 h-20 md:h-24 w-full md:w-64 bg-gray-100 rounded-2xl p-2 md:p-3 text-center flex items-center justify-center shadow-inner mr-2 md:mr-0"></div>
                    <div id="dice-container" class="w-20 h-20 md:w-24 md:h-24 bg-white rounded-2xl flex items-center justify-center shadow-md flex-shrink-0">
                        <div id="dice" class="dice text-5xl md:text-6xl">üé≤</div>
                    </div>
                </div>
            </div>
            <div id="board-container"></div>
        </div>
    </div>

    <!-- Mod√°ln√≠ okna -->
    <div id="modal-backdrop" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-50 p-4">
        <div id="reading-modal" class="modal bg-white rounded-2xl shadow-2xl p-4 sm:p-8 max-w-md w-full text-center hidden">
            <h2 id="reading-title" class="text-xl sm:text-2xl font-bold text-sky-600 mb-4">P≈ôeƒçti nahlas:</h2>
            <p id="reading-text" class="text-3xl sm:text-4xl font-bold mb-6 sm:mb-8 h-20 sm:h-24 flex items-center justify-center"></p>
            <div class="flex flex-col sm:flex-row justify-around space-y-2 sm:space-y-0 sm:space-x-2">
                <button id="btn-correct" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 sm:px-6 rounded-full text-base sm:text-lg shadow-lg transform hover:scale-105 transition-transform">P≈ôeƒçteno spr√°vnƒõ üëç</button>
                <button id="btn-incorrect" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 sm:px-6 rounded-full text-base sm:text-lg shadow-lg transform hover:scale-105 transition-transform">Chyba ve ƒçten√≠ üëé</button>
            </div>
        </div>
        <div id="result-modal" class="modal bg-white rounded-2xl shadow-2xl p-4 sm:p-8 max-w-md w-full text-center hidden">
            <h2 id="result-title" class="text-4xl sm:text-5xl font-bold mb-4"></h2>
            <p id="result-text" class="text-2xl text-gray-700 mb-6 sm:mb-8 h-16 sm:h-20 flex items-center justify-center"></p>
            <button id="btn-continue" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-full text-lg sm:text-xl shadow-lg transform hover:scale-105 transition-transform">Pokraƒçovat</button>
        </div>
        <div id="winner-modal" class="modal bg-white rounded-2xl shadow-2xl p-4 sm:p-8 max-w-md w-full text-center hidden">
            <h2 id="winner-title" class="text-4xl sm:text-5xl font-bold mb-4 text-amber-500">üéâ V√≠tƒõzstv√≠! üéâ</h2>
            <p id="winner-text" class="text-2xl sm:text-3xl text-gray-700 mb-6 sm:mb-8"></p>
            <button id="btn-restart" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-8 rounded-full text-lg sm:text-xl shadow-lg transform hover:scale-105 transition-transform">Hr√°t znovu</button>
        </div>
        <div id="target-selection-modal" class="modal bg-white rounded-2xl shadow-2xl p-4 sm:p-8 max-w-md w-full text-center hidden">
            <h2 class="text-2xl sm:text-3xl font-bold text-purple-600 mb-6">Vyber c√≠l</h2>
            <div id="target-buttons-container" class="flex flex-col space-y-3"></div>
        </div>
        <div id="sentence-settings-modal" class="modal bg-white rounded-2xl shadow-2xl p-4 sm:p-8 max-w-lg w-full text-center hidden">
            <h2 class="text-2xl sm:text-3xl font-bold text-gray-700 mb-6">Nastaven√≠ fr√°z√≠ ke ƒçten√≠</h2>
            <div id="sentence-list" class="max-h-64 overflow-y-auto space-y-2 mb-4 border p-2 rounded-lg"></div>
            <div class="flex space-x-2">
                <input type="text" id="new-sentence-input" placeholder="Nov√° fr√°ze..." class="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-emerald-500 focus:border-emerald-500">
                <button id="add-sentence-btn" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded-md shadow-md">P≈ôidat</button>
            </div>
            <button id="save-sentences-btn" class="mt-6 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-full text-lg shadow-lg">Ulo≈æit a zav≈ô√≠t</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- MOBILE RESPONSIVE HELPERS ---
            function adaptForMobile() {
                const isMobile = window.innerWidth < 640;
                const diceContainer = document.getElementById('dice-container');
                resizeBoardToSquares();
                if (isMobile && window.innerHeight < 650) diceContainer.classList.add('floating');
                else diceContainer.classList.remove('floating');
                applyLandscapeFullscreen();
                fitGameStage();
            }
            window.addEventListener('resize', adaptForMobile, { passive: true });
            window.addEventListener('orientationchange', () => setTimeout(adaptForMobile, 300));
            // --- HERN√ç DATA --- (nyn√≠ dynamick√° d√≠ky editoru mapy)
            let TOTAL_TILES = 32;
            let taskTiles = [3, 5, 7, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30];
            let maliceCardTiles = [6, 13, 21, 27];
            let boardConfig = {
                rows: 4,
                cols: 8,
                serpentine: true,
                tiles: [] // {id, type} where type in ['start','end','task','malice','normal']
            };
            const defaultBoardInitializer = () => {
                boardConfig.tiles = [];
                for (let i = 1; i <= boardConfig.rows * boardConfig.cols; i++) {
                    let type = 'normal';
                    if (i === 1) type = 'start';
                    else if (i === boardConfig.rows * boardConfig.cols) type = 'end';
                    else if (taskTiles.includes(i)) type = 'task';
                    else if (maliceCardTiles.includes(i)) type = 'malice';
                    boardConfig.tiles.push({ id: i, type });
                }
            };
            defaultBoardInitializer();
            const playerShapes = {
                circle: '<svg viewBox="0 0 100 100" fill="currentColor"><circle cx="50" cy="50" r="50"/></svg>',
                square: '<svg viewBox="0 0 100 100" fill="currentColor"><rect width="100" height="100" rx="10"/></svg>',
                triangle: '<svg viewBox="0 0 100 100" fill="currentColor"><polygon points="50,0 100,100 0,100"/></svg>',
                star: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>',
                heart: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>',
                person: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>'
            };
            const defaultColors = ['#f87171', '#60a5fa', '#34d399', '#facc15'];

            let readingSentences = ["M√°ma m√°.", "Mal√° lama mele.", "Ale, ale... mela!", "M√°ma mele. Ema mele.", "Ela. Lela. Ema.", "Lama mele.", "Ema m√° lem.", "Ale m√°ma!", "M√°ma l√°me.", "Ema l√°me lem.", "Lama ale mele m√°lo.", "Mal√° Ema.", "M√°ma a Ela.", "Lela a Ema.", "M√°lem m√°ma.", "Lama a m√°ma.", "Se.", "Sa.", "S√©.", "S√°.", "Les.", "Los.", "Osel.", "S√°m.", "Sama.", "Maso.", "M√°ma m√° maso.", "Ema se m√°.", "S√°l√°."];
            // (Odstranƒõno) Logika skl√°d√°n√≠ slov byla vypu≈°tƒõna ‚Äì hra nyn√≠ pou≈æ√≠v√° pouze ƒçtec√≠ √∫koly.

            const jupiKarty = [
                { title: "Jup√≠!", icon: "üöÄ", text: "Raketov√Ω start! Hoƒè kostkou je≈°tƒõ jednou.", action: async (gs) => { gs.extraTurn = true; continueTurn(); } },
                { title: "Jup√≠!", icon: "ü¶ò", text: "Velk√Ω skok! Postup o 4 pol√≠ƒçka dop≈ôedu.", action: async (gs) => { await movePlayer(gs.currentPlayerIndex, 4); processMoveEnd(gs.currentPlayerIndex); } },
                { title: "Jup√≠!", icon: "üó∫Ô∏è", text: "Chytr√° zkratka! Posu≈à se na nejbli≈æ≈°√≠ ≈ælut√© pol√≠ƒçko p≈ôed tebou.", action: async (gs) => { const currentPos = gs.players[gs.currentPlayerIndex].position; const nextTaskTile = taskTiles.find(t => t > currentPos) || TOTAL_TILES; const steps = nextTaskTile - currentPos; await movePlayer(gs.currentPlayerIndex, steps); processMoveEnd(gs.currentPlayerIndex); }},
                { title: "Jup√≠!", icon: "üí®", text: "V√≠tr do zad! Postup o 2 pol√≠ƒçka vp≈ôed.", action: async (gs) => { await movePlayer(gs.currentPlayerIndex, 2); processMoveEnd(gs.currentPlayerIndex); } },
                { title: "Jup√≠!", icon: "üë¢", text: "Sedmim√≠lov√© boty! Posu≈à se o 7 pol√≠ƒçek vp≈ôed.", action: async (gs) => { await movePlayer(gs.currentPlayerIndex, 7); processMoveEnd(gs.currentPlayerIndex); } },
                { title: "Jup√≠!", icon: "‚ö°", text: "Dvojit√° rychlost! P≈ôi sv√©m p≈ô√≠≈°t√≠m hodu se posune≈° o dvojn√°sobek.", action: async (gs) => { gs.players[gs.currentPlayerIndex].doubleNextRoll = true; continueTurn(); } },
                { title: "Jup√≠!", icon: "üéÅ", text: "Dar pro kamar√°dy! V≈°ichni ostatn√≠ hr√°ƒçi postupuj√≠ o 1 pol√≠ƒçko.", action: async (gs) => { for(let i = 0; i < gs.players.length; i++) { if (i !== gs.currentPlayerIndex) { await movePlayer(i, 1); } } processMoveEnd(gs.currentPlayerIndex); }},
                { title: "Jup√≠!", icon: "üíÉ", text: "Taneƒçn√≠k radosti! V≈°ichni tanƒç√≠ a ty postupuje≈° o 3 pol√≠ƒçka.", action: async (gs) => { await movePlayer(gs.currentPlayerIndex, 3); processMoveEnd(gs.currentPlayerIndex); } }
            ];
            const jejdaKarty = [
                { title: "Jejda!", icon: "ü§¢", text: "Klouzav√© bl√°to! Vra≈• se o 3 pol√≠ƒçka zpƒõt.", action: async (gs, targetIndex) => { await movePlayer(targetIndex, -3); processMoveEnd(targetIndex); } },
                { title: "Jejda!", icon: "üëü", text: "Rozv√°zan√° tkaniƒçka! Stoj√≠≈° jedno kolo.", action: async (gs, targetIndex) => { gs.players[targetIndex].skipTurn = true; continueTurn(); } },
                { title: "Jejda!", icon: "üåø", text: "Bludn√© ko≈ôeny! Vra≈• se o 2 pol√≠ƒçka zpƒõt.", action: async (gs, targetIndex) => { await movePlayer(targetIndex, -2); processMoveEnd(targetIndex); } },
                { title: "Jejda!", icon: "ü™∞", text: "Ospal√° moucha! V p≈ô√≠≈°t√≠m kole se posune≈° jen o 1 pol√≠ƒçko.", action: async (gs, targetIndex) => { gs.players[targetIndex].nextRollMax = 1; continueTurn(); } },
                { title: "Jejda!", icon: "üå™Ô∏è", text: "Zafoukal v√≠tr! Vra≈• se na nejbli≈æ≈°√≠ ≈ælut√© pol√≠ƒçko za tebou.", action: async (gs, targetIndex) => { const currentPos = gs.players[targetIndex].position; const prevTaskTile = [...taskTiles].reverse().find(t => t < currentPos) || 0; const steps = prevTaskTile - currentPos; await movePlayer(targetIndex, steps); processMoveEnd(targetIndex); }},
                { title: "Jejda!", icon: "üå∞", text: "≈†i≈°kov√° brzda! Vra≈• se o 1 pol√≠ƒçko zpƒõt.", action: async (gs, targetIndex) => { await movePlayer(targetIndex, -1); processMoveEnd(targetIndex); } },
                { title: "Jejda!", icon: "üîÑ", text: "Opaƒçn√Ω den! Hoƒè kostkou a jdi dozadu.", action: async (gs, targetIndex) => { gs.players[targetIndex].reverseNextRoll = true; continueTurn(); } },
                { title: "Jejda!", icon: "‚òÅÔ∏è", text: "Sm≈Øla pro v≈°echny! V≈°ichni hr√°ƒçi se mus√≠ posunout o 1 pol√≠ƒçko zpƒõt.", action: async (gs) => { for(let i = 0; i < gs.players.length; i++) { await movePlayer(i, -1, true); } continueTurn(); }}
            ];
            const skodolibeKarty = [
                { name: "≈†≈•ouchanec", icon: "üëä", description: "Posu≈à soupe≈ôe o 2 pol√≠ƒçka zpƒõt.", action: async (gs, targetIndex) => { await movePlayer(targetIndex, -2); }},
                { name: "V√Ωmƒõna", icon: "üîÑ", description: "Vymƒõ≈à si m√≠sto se soupe≈ôem.", action: async (gs, targetIndex) => { const p1 = gs.players[gs.currentPlayerIndex]; const p2 = gs.players[targetIndex]; [p1.position, p2.position] = [p2.position, p1.position]; updatePlayerPositions(); messageLog.textContent = `${p1.name} si vymƒõnil(a) m√≠sto s ${p2.name}!`; await new Promise(r => setTimeout(r, 1000)); }},
                { name: "Zastaven√≠", icon: "üõë", description: "Soupe≈ô p≈ô√≠≈°t√≠ kolo stoj√≠.", action: async (gs, targetIndex) => { const opponent = gs.players[targetIndex]; opponent.skipTurn = true; messageLog.textContent = `${opponent.name} bude p≈ô√≠≈°t√≠ kolo st√°t!`; await new Promise(r => setTimeout(r, 1000)); }},
                { name: "Zkou≈°ka ƒçten√≠", icon: "üìñ", description: "Donu≈• soupe≈ôe ƒç√≠st.", action: async (gs, targetIndex) => { await showReadingCard(true, targetIndex); }},
                { name: "Dvojit√° sm≈Øla", icon: "üíÄ", description: "Soupe≈ô si l√≠zne dvƒõ Jejda karty.", action: async (gs, targetIndex) => { messageLog.textContent = `Dvojit√° sm≈Øla pro ${gs.players[targetIndex].name}!`; await new Promise(r => setTimeout(r, 1000)); for (let i = 0; i < 2; i++) { const card = jejdaKarty[Math.floor(Math.random() * jejdaKarty.length)]; await showResultModal(card); await card.action(gameState, targetIndex); } }}
            ];
            let gameState = {};
            const setupScreen = document.getElementById('setup-screen'); const gameContainer = document.getElementById('game-container'); const startGameBtn = document.getElementById('start-game-btn'); const boardContainer = document.getElementById('board-container'); const diceEl = document.getElementById('dice'); const turnIndicator = document.getElementById('turn-indicator'); const messageLog = document.getElementById('message-log'); const modalBackdrop = document.getElementById('modal-backdrop'); const readingModal = document.getElementById('reading-modal'); const resultModal = document.getElementById('result-modal'); const winnerModal = document.getElementById('winner-modal'); const targetSelectionModal = document.getElementById('target-selection-modal'); const maliceCardsContainer = document.getElementById('malice-cards-container'); const playerCountSelector = document.getElementById('player-count-selector'); const playerSetupsContainer = document.getElementById('player-setups-container'); const sentenceSettingsBtn = document.getElementById('sentence-settings-btn'); const sentenceSettingsModal = document.getElementById('sentence-settings-modal');
            // Now that boardContainer is defined, perform initial mobile adaptation
            adaptForMobile();
            let selectedPlayerCount = 2;
            // Map editor elements (added later after DOM query for modal)

            startGameBtn.addEventListener('click', () => {
                const playerSettings = [];
                for (let i = 0; i < selectedPlayerCount; i++) {
                    const name = document.getElementById(`player${i+1}-name`).value || `Hr√°ƒç ${i+1}`;
                    const color = document.getElementById(`player${i+1}-color`).value;
                    const shape = document.querySelector(`input[name="player${i+1}-shape"]:checked`).value;
                    playerSettings.push({ name, color, shape });
                }
                setupScreen.classList.add('hidden'); gameContainer.classList.remove('hidden'); initGame(playerSettings);
            });

            playerCountSelector.addEventListener('click', (e) => {
                if (e.target.dataset.count) {
                    selectedPlayerCount = parseInt(e.target.dataset.count);
                    playerCountSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('selected'));
                    e.target.classList.add('selected');
                    renderPlayerSetups();
                }
            });

            playerSetupsContainer.addEventListener('click', e => {
                const btn = e.target.closest('.shape-btn');
                if (btn) {
                    const setupBlock = btn.closest('.p-4');
                    setupBlock.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                }
            });

            function renderPlayerSetups() {
                playerSetupsContainer.innerHTML = '';
                for (let i = 0; i < selectedPlayerCount; i++) {
                    playerSetupsContainer.insertAdjacentHTML('beforeend', createPlayerSetupHTML(i));
                }
            }

            function createPlayerSetupHTML(index) {
                const playerNum = index + 1;
                const shapesHTML = Object.keys(playerShapes).map((shape, shapeIndex) => `<label class="shape-btn ${shapeIndex === index % Object.keys(playerShapes).length ? 'selected' : ''}"><input type="radio" name="player${playerNum}-shape" value="${shape}" class="sr-only" ${shapeIndex === index % Object.keys(playerShapes).length ? 'checked' : ''}>${playerShapes[shape]}</label>`).join('');
                return `<div class="p-4 border rounded-xl bg-gray-50"><div class="flex items-center justify-between"><label for="player${playerNum}-name" class="block text-xl font-bold text-gray-700">Hr√°ƒç ${playerNum}</label><input type="color" id="player${playerNum}-color" value="${defaultColors[index]}"></div><input type="text" id="player${playerNum}-name" placeholder="Zadej jm√©no" value="Hr√°ƒç ${playerNum}" class="mt-2 w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-emerald-500 focus:border-emerald-500"><div class="mt-3"><p class="text-sm text-gray-600 mb-2">Vyber tvar:</p><div class="flex justify-center space-x-2 flex-wrap gap-2">${shapesHTML}</div></div></div>`;
            }

            sentenceSettingsBtn.addEventListener('click', () => { renderSentenceList(); showModal('sentence-settings'); });
            // P≈ôidat tlaƒç√≠tko pro editor mapy
            const mapEditorBtn = document.createElement('button');
            mapEditorBtn.id = 'map-editor-btn';
            mapEditorBtn.className = 'w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-full text-lg shadow-md transform hover:scale-105 transition-transform';
            mapEditorBtn.textContent = 'Editor mapy';
            document.querySelector('#setup-screen .mt-6').insertBefore(mapEditorBtn, document.getElementById('sentence-settings-btn'));
            mapEditorBtn.addEventListener('click', () => { openMapEditor(); });
            document.getElementById('save-sentences-btn').addEventListener('click', () => { hideModal(); });
            document.getElementById('add-sentence-btn').addEventListener('click', () => {
                const input = document.getElementById('new-sentence-input'); const newSentence = input.value.trim();
                if (newSentence) { readingSentences.push(newSentence); input.value = ''; renderSentenceList(); }
            });
            
            function renderSentenceList() {
                const listContainer = document.getElementById('sentence-list'); listContainer.innerHTML = '';
                if (readingSentences.length === 0) { listContainer.innerHTML = '<p class="text-gray-500">Seznam je pr√°zdn√Ω. P≈ôidejte fr√°zi!</p>'; }
                else { readingSentences.forEach((sentence, index) => { const item = document.createElement('div'); item.className = 'flex items-center justify-between bg-gray-100 p-2 rounded'; item.innerHTML = `<span class="text-left">${sentence}</span><button data-index="${index}" class="delete-sentence-btn text-red-500 hover:text-red-700 font-bold text-xl">&times;</button>`; listContainer.appendChild(item); }); }
                document.querySelectorAll('.delete-sentence-btn').forEach(btn => { btn.addEventListener('click', (e) => { const index = parseInt(e.target.dataset.index); readingSentences.splice(index, 1); renderSentenceList(); }); });
            }
            
            function initGame(settings) {
                gameState = { players: settings.map((s, i) => ({ id: i + 1, name: s.name, color: s.color, shape: s.shape, position: 1, maliceCards: [], skipTurn: false, doubleNextRoll: false, nextRollMax: 6, reverseNextRoll: false })), currentPlayerIndex: 0, isMoving: false, extraTurn: false, gameover: false, };
                // Rebuild derived arrays from boardConfig
                TOTAL_TILES = boardConfig.rows * boardConfig.cols;
                taskTiles = boardConfig.tiles.filter(t => t.type === 'task').map(t => t.id);
                maliceCardTiles = boardConfig.tiles.filter(t => t.type === 'malice').map(t => t.id);
                drawBoard();
                gameState.players.forEach(player => {
                    const el = document.createElement('div'); el.id = `player${player.id}`; el.className = `player`;
                    el.innerHTML = playerShapes[player.shape]; el.style.color = player.color;
                    boardContainer.appendChild(el); player.el = el;
                });
                setTimeout(() => updatePlayerPositions(), 100);
                updateTurnIndicator(); messageLog.textContent = `${gameState.players[0].name} zaƒç√≠n√°. Hoƒè kostkou!`;
                diceEl.addEventListener('click', handleDiceRoll);
                document.getElementById('btn-restart').addEventListener('click', () => { hideModal(); gameContainer.classList.add('hidden'); setupScreen.classList.remove('hidden'); });
            }

            function drawBoard() {
                boardContainer.innerHTML = '';
                boardContainer.style.gridTemplateColumns = `repeat(${boardConfig.cols}, 1fr)`;
                boardContainer.style.gridTemplateRows = `repeat(${boardConfig.rows}, 1fr)`;
                // Build visual placement list with serpentine logic
                const placement = [];
                let id = 1;
                for (let r = 0; r < boardConfig.rows; r++) {
                    const rowIds = [];
                    for (let c = 0; c < boardConfig.cols; c++) { rowIds.push(id++); }
                    if (boardConfig.serpentine && r % 2 === 1) rowIds.reverse();
                    placement.push(...rowIds);
                }
                placement.forEach(tileId => {
                    const tileMeta = boardConfig.tiles.find(t => t.id === tileId) || { id: tileId, type: 'normal' };
                    const tile = document.createElement('div'); tile.dataset.tileId = tileMeta.id;
                    let tileBgClass = '';
                    if (tileMeta.type === 'start') tileBgClass = 'start';
                    else if (tileMeta.type === 'end') tileBgClass = 'end';
                    else if (tileMeta.type === 'malice') tileBgClass = 'malice';
                    else if (tileMeta.type === 'task') tileBgClass = 'bg-orange-300';
                    else tileBgClass = 'bg-sky-200';
                    tile.className = `tile ${tileBgClass}`;
                    const number = document.createElement('span'); number.className = 'tile-number'; number.textContent = tileMeta.id; tile.appendChild(number);
                    const content = document.createElement('span'); content.className = 'tile-content';
                    if (tileMeta.type === 'start') content.textContent = '‚ñ∂Ô∏è';
                    else if (tileMeta.type === 'end') content.textContent = 'üèÅ';
                    else if (tileMeta.type === 'malice') content.textContent = 'üòà';
                    else if (tileMeta.type === 'task') content.textContent = '‚ùì';
                    tile.appendChild(content);
                    boardContainer.appendChild(tile);
                });
                // After creating tiles, enforce square ratio by adjusting container height
                resizeBoardToSquares();
            }

            async function handleDiceRoll() {
                if (gameState.isMoving || gameState.gameover) return; gameState.isMoving = true;
                diceEl.classList.add('rolling'); await new Promise(resolve => setTimeout(resolve, 700)); diceEl.classList.remove('rolling');
                let roll = Math.ceil(Math.random() * 6); const player = gameState.players[gameState.currentPlayerIndex];
                if (player.nextRollMax < 6) { roll = Math.min(roll, player.nextRollMax); player.nextRollMax = 6; }
                let move = player.doubleNextRoll ? roll * 2 : roll; if (player.reverseNextRoll) { move = -roll; }
                diceEl.textContent = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'][roll - 1];
                messageLog.textContent = `${player.name} hodil(a) ${roll}.`;
                player.doubleNextRoll = false; player.reverseNextRoll = false;
                await movePlayer(gameState.currentPlayerIndex, move);
                processMoveEnd(gameState.currentPlayerIndex);
            }

            function processMoveEnd(playerIndex) {
                if (gameState.gameover) return;
                const player = gameState.players[playerIndex]; const currentPos = player.position;
                if (maliceCardTiles.includes(currentPos)) { 
                    if (playerIndex === gameState.currentPlayerIndex) { 
                        setTimeout(() => pickupMaliceCard(playerIndex), 500); 
                    } else { 
                        if (gameState.players.length > 0) continueTurn(); 
                    } 
                }
                else if (taskTiles.includes(currentPos)) { 
                    if (playerIndex === gameState.currentPlayerIndex) { 
                        // V≈ædy ƒçtec√≠ karta (scramble hra odstranƒõna)
                        setTimeout(() => showReadingCard(), 500); 
                    } else { 
                        if (gameState.players.length > 0) continueTurn(); 
                    } 
                }
                else { if (gameState.players.length > 0) continueTurn(); }
            }
            
            function continueTurn() {
                if (gameState.gameover) return; const player = gameState.players[gameState.currentPlayerIndex];
                if (!gameState.extraTurn) { nextTurn(); }
                else { gameState.extraTurn = false; messageLog.textContent = `${player.name} h√°z√≠ znovu!`; gameState.isMoving = false; updateMaliceCardUI(); }
            }

            function movePlayer(playerIndex, steps, silent = false) {
                 return new Promise(async resolve => {
                    const player = gameState.players[playerIndex]; const startPos = player.position;
                    let targetPos = startPos + steps;
                    if (targetPos < 1) targetPos = 1; if (targetPos > TOTAL_TILES) targetPos = TOTAL_TILES;
                    const stepDirection = steps > 0 ? 1 : -1;
                    for (let i = startPos + stepDirection; (stepDirection > 0 ? i <= targetPos : i >= targetPos); i += stepDirection) {
                        player.position = i; updatePlayerPositions(); await new Promise(r => setTimeout(r, 200));
                    }
                    player.position = targetPos; updatePlayerPositions();
                    if (!silent && player.position >= TOTAL_TILES && playerIndex === gameState.currentPlayerIndex) { endGame(); }
                    resolve();
                });
            }

            function nextTurn() {
                if (gameState.gameover) return;
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                updateTurnIndicator(); const nextPlayer = gameState.players[gameState.currentPlayerIndex];
                if (nextPlayer.skipTurn) { nextPlayer.skipTurn = false; messageLog.textContent = `${nextPlayer.name} stoj√≠.`; setTimeout(() => nextTurn(), 1000); }
                else { messageLog.textContent = `Na ≈ôadƒõ je ${nextPlayer.name}.`; gameState.isMoving = false; updateMaliceCardUI(); }
            }
            
            function endGame() {
                gameState.gameover = true; const winner = gameState.players[gameState.currentPlayerIndex];
                document.getElementById('winner-text').textContent = `${winner.name} dorazil(a) do c√≠le!`;
                showModal('winner');
            }

            async function pickupMaliceCard(playerIndex) {
                const player = gameState.players[playerIndex]; 
                const card = skodolibeKarty[Math.floor(Math.random() * skodolibeKarty.length)];
                player.maliceCards.push(card); 
                updateMaliceCardUI();
                
                const cardDisplay = card.icon ? `${card.icon} ${card.name}` : card.name;
                await showResultModal({title: "üòà", text: `Z√≠skal(a) jsi ≈†kodolibou kartu: ${cardDisplay}!`});
                continueTurn();
            }

            function updateMaliceCardUI() {
                maliceCardsContainer.innerHTML = ''; 
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                currentPlayer.maliceCards.forEach((card, index) => {
                    const btn = document.createElement('button'); 
                    btn.className = 'malice-card-btn'; 
                    
                    // Zobrazit ikonku a n√°zev karty
                    const displayText = card.icon ? `${card.icon} ${card.name}` : card.name;
                    btn.textContent = displayText;
                    
                    btn.disabled = gameState.isMoving;
                    btn.onclick = async () => {
                        if (gameState.players.length <= 2) { 
                            const opponentIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length; 
                            playMaliceCard(card, index, opponentIndex); 
                        } else { 
                            showTargetSelectionModal(card, index); 
                        }
                    };
                    maliceCardsContainer.appendChild(btn);
                });
            }

            async function playMaliceCard(card, cardIndex, targetIndex) {
                maliceCardsContainer.querySelectorAll('button').forEach(b => b.disabled = true); diceEl.classList.add('disabled');
                const currentPlayer = gameState.players[gameState.currentPlayerIndex]; const targetPlayer = gameState.players[targetIndex];
                messageLog.textContent = `${currentPlayer.name} zahr√°l(a) kartu ${card.name} na ${targetPlayer.name}!`;
                await new Promise(r => setTimeout(r, 1500));
                await card.action(gameState, targetIndex); currentPlayer.maliceCards.splice(cardIndex, 1);
                messageLog.textContent = `Na ≈ôadƒõ je ${currentPlayer.name}. Hoƒè kostkou!`;
                diceEl.classList.remove('disabled'); updateMaliceCardUI();
            }

            function showTargetSelectionModal(card, cardIndex) {
                const container = document.getElementById('target-buttons-container'); container.innerHTML = '';
                gameState.players.forEach((player, index) => {
                    if (index !== gameState.currentPlayerIndex) {
                        const btn = document.createElement('button'); btn.className = 'bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg';
                        btn.textContent = player.name; btn.style.color = player.color;
                        btn.onclick = () => { hideModal(); playMaliceCard(card, cardIndex, index); };
                        container.appendChild(btn);
                    }
                });
                showModal('target-selection');
            }
            
            async function showReadingCard(isForced = false, targetPlayerIndex = gameState.currentPlayerIndex) {
                const sentence = readingSentences[Math.floor(Math.random() * readingSentences.length)];
                const readingTitle = document.getElementById('reading-title');
                readingTitle.textContent = isForced ? `ƒåte ${gameState.players[targetPlayerIndex].name}:` : 'P≈ôeƒçti nahlas:';
                document.getElementById('reading-text').textContent = sentence;
                const correctHandler = () => { if (isForced) { handleForcedReadingResult(true, targetPlayerIndex); } else { handleCardResult(true); } cleanup(); };
                const incorrectHandler = () => { if (isForced) { handleForcedReadingResult(false, targetPlayerIndex); } else { handleCardResult(false); } cleanup(); };
                const btnCorrect = document.getElementById('btn-correct'); const btnIncorrect = document.getElementById('btn-incorrect');
                btnCorrect.onclick = correctHandler; btnIncorrect.onclick = incorrectHandler;
                function cleanup() { btnCorrect.onclick = null; btnIncorrect.onclick = null; }
                showModal('reading');
            }
            
            async function handleForcedReadingResult(isCorrect, targetPlayerIndex) {
                 hideModal();
                 if (!isCorrect) {
                     messageLog.textContent = `${gameState.players[targetPlayerIndex].name} neuspƒõl(a)!`; await new Promise(r => setTimeout(r, 1000));
                     const card = jejdaKarty[Math.floor(Math.random() * jejdaKarty.length)]; await showResultModal(card); await card.action(gameState, targetPlayerIndex);
                 } else { messageLog.textContent = `${gameState.players[targetPlayerIndex].name} uspƒõl(a)!`; await new Promise(r => setTimeout(r, 1000)); }
            }

            async function handleCardResult(isCorrect) {
                hideModal(); await new Promise(r => setTimeout(r, 300));
                const cardDeck = isCorrect ? jupiKarty : jejdaKarty; const card = cardDeck[Math.floor(Math.random() * cardDeck.length)];
                await showResultModal(card); await card.action(gameState, gameState.currentPlayerIndex);
            }

            function showResultModal(card) {
                return new Promise(resolve => {
                    const titleElement = document.getElementById('result-title');
                    const textElement = document.getElementById('result-text');
                    
                    // Zobrazit titulek s ikonkou pokud existuje
                    const displayTitle = card.icon ? `${card.icon} ${card.title}` : card.title;
                    titleElement.textContent = displayTitle;
                    textElement.textContent = card.text;
                    
                    const titleClasses = "text-4xl sm:text-5xl font-bold mb-4";
                    if (card.title === "Jup√≠!") { titleElement.className = `${titleClasses} text-amber-500`; }
                    else if (card.title === "Jejda!") { titleElement.className = `${titleClasses} text-rose-500`; }
                    else { titleElement.className = `${titleClasses} text-purple-500`; }
                    
                    showModal('result');
                    document.getElementById('btn-continue').onclick = () => { hideModal(); resolve(); };
                });
            }

            // (Odstranƒõno) Sekce Word Scramble Game Logic byla odstranƒõna.

            function showModal(type) {
                modalBackdrop.classList.remove('hidden');
                                ['reading', 'result', 'winner', 'target-selection', 'sentence-settings', 'map-editor'].forEach(id => {
                    document.getElementById(`${id}-modal`).classList.add('hidden');
                });
                const modalEl = document.getElementById(`${type}-modal`);
                if (modalEl) modalEl.classList.remove('hidden');
            }

                        // ================== MAP EDITOR ==================
                        // Vytvo≈ôen√≠ modalu pro map editor (vlo≈æ√≠me na konec modal-backdropu)
                        const mapEditorModal = document.createElement('div');
                        mapEditorModal.id = 'map-editor-modal';
                        mapEditorModal.className = 'modal bg-white rounded-2xl shadow-2xl p-4 sm:p-6 max-w-3xl w-full text-center hidden';
                        mapEditorModal.innerHTML = `
                                <h2 class="text-2xl sm:text-3xl font-bold text-indigo-600 mb-4">Editor mapy</h2>
                                <div class="grid md:grid-cols-5 gap-4 text-left mb-4">
                                    <div class="md:col-span-2 space-y-4">
                                        <div>
                                            <label class="block text-sm font-semibold mb-1">≈ò√°dky</label>
                                            <input id="map-rows" type="number" min="1" max="12" value="${boardConfig.rows}" class="w-full border rounded px-2 py-1" />
                                        </div>
                                        <div>
                                            <label class="block text-sm font-semibold mb-1">Sloupce</label>
                                            <input id="map-cols" type="number" min="1" max="16" value="${boardConfig.cols}" class="w-full border rounded px-2 py-1" />
                                        </div>
                                        <div class="flex items-center space-x-2">
                                            <input id="map-serpentine" type="checkbox" ${boardConfig.serpentine ? 'checked' : ''} />
                                            <label for="map-serpentine" class="text-sm font-semibold select-none">Serpentinov√© po≈ôad√≠</label>
                                        </div>
                                        <div>
                                            <label class="block text-sm font-semibold mb-1">Procento √∫kolov√Ωch pol√≠ (‚ùì)</label>
                                            <input id="task-ratio" type="number" min="0" max="90" value="35" class="w-full border rounded px-2 py-1" />
                                        </div>
                                        <div>
                                            <label class="block text-sm font-semibold mb-1">Procento ≈°kodolib√Ωch pol√≠ (üòà)</label>
                                            <input id="malice-ratio" type="number" min="0" max="60" value="12" class="w-full border rounded px-2 py-1" />
                                        </div>
                                        <div>
                                            <p class="text-sm font-semibold mb-1">Paleta</p>
                                            <div id="tile-palette" class="flex flex-wrap gap-2">
                                                <div draggable="true" data-type="task" class="cursor-move px-3 py-1 rounded-full bg-orange-300 font-semibold shadow">‚ùì √ökol</div>
                                                <div draggable="true" data-type="malice" class="cursor-move px-3 py-1 rounded-full bg-fuchsia-400 text-white font-semibold shadow">üòà ≈†kodolib√©</div>
                                                <div draggable="true" data-type="normal" class="cursor-move px-3 py-1 rounded-full bg-sky-200 font-semibold shadow">‚Ä¢ Norm√°ln√≠</div>
                                                <div class="px-3 py-1 rounded-full bg-emerald-400 text-white font-semibold shadow opacity-70" title="Start je pevnƒõ d√°n">‚ñ∂Ô∏è Start</div>
                                                <div class="px-3 py-1 rounded-full bg-emerald-500 text-white font-semibold shadow opacity-70" title="C√≠l je pevnƒõ d√°n">üèÅ C√≠l</div>
                                            </div>
                                            <p class="text-xs text-gray-500 mt-1">P≈ôet√°hni typ na pol√≠ƒçko. Start = 1, C√≠l = posledn√≠.</p>
                                        </div>
                                        <div class="flex gap-2 flex-wrap">
                                            <button id="apply-size-btn" class="flex-1 bg-gray-200 hover:bg-gray-300 rounded px-3 py-2 font-semibold">Zmƒõnit velikost</button>
                                            <button id="reset-map-btn" class="flex-1 bg-gray-200 hover:bg-gray-300 rounded px-3 py-2 font-semibold">Reset</button>
                                            <button id="generate-map-btn" class="flex-1 bg-indigo-100 hover:bg-indigo-200 text-indigo-700 rounded px-3 py-2 font-semibold">üé≤ Vygenerovat</button>
                                        </div>
                                    </div>
                                    <div class="md:col-span-3">
                                        <div id="map-grid-preview" class="grid gap-1 border rounded p-2 bg-gray-50" style="grid-template-columns: repeat(${boardConfig.cols}, minmax(0,1fr));"></div>
                                    </div>
                                </div>
                                <div class="flex flex-col sm:flex-row gap-3 mt-4">
                                    <button id="close-map-editor" class="flex-1 bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-full">Zav≈ô√≠t</button>
                                    <button id="save-map-editor" class="flex-1 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-full">Ulo≈æit mapu</button>
                                </div>
                        `;
                        document.getElementById('modal-backdrop').appendChild(mapEditorModal);

                        function openMapEditor() {
                                renderMapEditorGrid();
                                showModal('map-editor');
                        }

                        function renderMapEditorGrid() {
                                const grid = document.getElementById('map-grid-preview');
                                grid.style.gridTemplateColumns = `repeat(${boardConfig.cols}, minmax(0,1fr))`;
                                grid.innerHTML = '';
                                // serpentine placement for preview to match game board
                                const placement = [];
                                let id = 1;
                                for (let r = 0; r < boardConfig.rows; r++) {
                                        const rowIds = [];
                                        for (let c = 0; c < boardConfig.cols; c++) rowIds.push(id++);
                                        if (boardConfig.serpentine && r % 2 === 1) rowIds.reverse();
                                        placement.push(...rowIds);
                                }
                                placement.forEach(tileId => {
                                        const meta = boardConfig.tiles.find(t => t.id === tileId) || { id: tileId, type: 'normal' };
                                        const div = document.createElement('div');
                                        div.className = 'relative text-xs md:text-sm aspect-square flex items-center justify-center font-bold rounded select-none border border-white shadow-inner';
                                        div.dataset.id = meta.id;
                                        div.draggable = true;
                                        let bg = 'bg-sky-200'; let symbol = '';
                                        if (meta.type === 'start') { bg = 'start bg-emerald-400 text-white'; symbol = '‚ñ∂Ô∏è'; }
                                        else if (meta.type === 'end') { bg = 'end bg-emerald-500 text-white'; symbol = 'üèÅ'; }
                                        else if (meta.type === 'task') { bg = 'bg-orange-300'; symbol = '‚ùì'; }
                                        else if (meta.type === 'malice') { bg = 'bg-fuchsia-400 text-white'; symbol = 'üòà'; }
                                        div.className += ' ' + bg;
                                        div.textContent = symbol || meta.id;
                                        // Drag target
                                        div.addEventListener('dragover', e => { e.preventDefault(); div.classList.add('ring', 'ring-indigo-400'); });
                                        div.addEventListener('dragleave', () => div.classList.remove('ring', 'ring-indigo-400'));
                                        div.addEventListener('drop', e => {
                                                e.preventDefault(); div.classList.remove('ring', 'ring-indigo-400');
                                                const type = e.dataTransfer.getData('tile-type');
                                                if (!type) return;
                                                applyTileType(meta.id, type);
                                                renderMapEditorGrid();
                                        });
                                        grid.appendChild(div);
                                });
                        }

                        function applyTileType(id, type) {
                                if (id === 1 || id === boardConfig.rows * boardConfig.cols) return; // keep start/end fixed
                                const tile = boardConfig.tiles.find(t => t.id === id);
                                if (tile) tile.type = type; else boardConfig.tiles.push({ id, type });
                        }

            function generateRandomMap() {
                const total = boardConfig.rows * boardConfig.cols;
                const interiorIds = [];
                for (let i = 2; i < total; i++) interiorIds.push(i);
                const shuffled = [...interiorIds].sort(() => Math.random() - 0.5);
                // ƒåten√≠ hodnot z UI (procenta) a p≈ôevod na poƒçty
                const taskRatioInput = Math.min(100, Math.max(0, parseFloat(document.getElementById('task-ratio')?.value) || 0));
                const maliceRatioInput = Math.min(100, Math.max(0, parseFloat(document.getElementById('malice-ratio')?.value) || 0));
                let taskCount = Math.round(interiorIds.length * (taskRatioInput / 100));
                let maliceCount = Math.round(interiorIds.length * (maliceRatioInput / 100));
                // Zaji≈°tƒõn√≠ minim√°ln√≠ch hodnot (alespo≈à 1 √∫kol pro hratelnost)
                if (taskCount === 0 && interiorIds.length > 0) taskCount = 1;
                // Omezit souƒçet aby nep≈ôekroƒçil interi√©r
                if (taskCount + maliceCount > interiorIds.length) {
                    // Preferenƒçnƒõ sni≈æujeme malice count
                    maliceCount = Math.max(0, interiorIds.length - taskCount);
                }
                // Pokud st√°le 0 a existuje prostor, p≈ôidej jedno ≈°kodolib√© pokud byl po≈æadavek > 0
                if (maliceCount === 0 && maliceRatioInput > 0 && (taskCount < interiorIds.length)) maliceCount = 1;
                const taskSet = new Set(shuffled.slice(0, taskCount));
                const maliceSet = new Set();
                let idx = taskCount;
                while (maliceSet.size < maliceCount && idx < shuffled.length) {
                    const cand = shuffled[idx++];
                    if (!taskSet.has(cand)) maliceSet.add(cand);
                }
                boardConfig.tiles = [];
                for (let i = 1; i <= total; i++) {
                    let type = 'normal';
                    if (i === 1) type = 'start';
                    else if (i === total) type = 'end';
                    else if (taskSet.has(i)) type = 'task';
                    else if (maliceSet.has(i)) type = 'malice';
                    boardConfig.tiles.push({ id: i, type });
                }
            }

                        // Palette drag logic
                        document.addEventListener('dragstart', e => {
                                const t = e.target;
                                if (t && t.getAttribute('draggable') === 'true' && t.dataset.type) {
                                        e.dataTransfer.setData('tile-type', t.dataset.type);
                                }
                        });

                        // Buttons inside modal
                        mapEditorModal.addEventListener('click', e => {
                                if (e.target.id === 'close-map-editor') hideModal();
                                if (e.target.id === 'reset-map-btn') { defaultBoardInitializer(); renderMapEditorGrid(); }
                                if (e.target.id === 'generate-map-btn') { generateRandomMap(); renderMapEditorGrid(); }
                                if (e.target.id === 'apply-size-btn') {
                                        const newRows = parseInt(document.getElementById('map-rows').value) || boardConfig.rows;
                                        const newCols = parseInt(document.getElementById('map-cols').value) || boardConfig.cols;
                                        const serp = document.getElementById('map-serpentine').checked;
                                        boardConfig.rows = Math.min(Math.max(newRows,1), 12);
                                        boardConfig.cols = Math.min(Math.max(newCols,1), 16);
                                        boardConfig.serpentine = serp;
                                        // Reinitialize tiles adjusting to new size
                                        const oldTiles = [...boardConfig.tiles];
                                        boardConfig.tiles = [];
                                        for (let i = 1; i <= boardConfig.rows * boardConfig.cols; i++) {
                                                let existing = oldTiles.find(t => t.id === i);
                                                let type = existing ? existing.type : 'normal';
                                                if (i === 1) type = 'start';
                                                else if (i === boardConfig.rows * boardConfig.cols) type = 'end';
                                                boardConfig.tiles.push({ id: i, type });
                                        }
                                        renderMapEditorGrid();
                                }
                                if (e.target.id === 'save-map-editor') {
                                        // Persist arrays for game start (will be re-derived in initGame too)
                                        taskTiles = boardConfig.tiles.filter(t => t.type === 'task').map(t => t.id);
                                        maliceCardTiles = boardConfig.tiles.filter(t => t.type === 'malice').map(t => t.id);
                                        TOTAL_TILES = boardConfig.rows * boardConfig.cols;
                                        hideModal();
                                }
                        });

                        // Toggle serpentine change on checkbox change (live preview)
                        mapEditorModal.addEventListener('change', e => {
                                if (e.target.id === 'map-serpentine') { boardConfig.serpentine = e.target.checked; renderMapEditorGrid(); }
                        });
                        // ================== END MAP EDITOR ==================

            function hideModal() { modalBackdrop.classList.add('hidden'); }

            function updatePlayerPositions() {
                if (!gameState.players) return; const firstTile = document.querySelector('[data-tile-id="1"]'); if (!firstTile) return;
                const playerSize = firstTile.offsetWidth * 0.4;
                const positions = {}; gameState.players.forEach(p => { if (!positions[p.position]) positions[p.position] = []; positions[p.position].push(p.id); });
                gameState.players.forEach((player) => {
                    player.el.style.width = `${playerSize}px`; player.el.style.height = `${playerSize}px`;
                    const tileId = player.position; if (tileId < 1) return;
                    const targetTile = document.querySelector(`[data-tile-id="${tileId}"]`);
                    if (targetTile) {
                        const tileRect = targetTile.getBoundingClientRect(); const boardRect = boardContainer.getBoundingClientRect();
                        const playersOnTile = positions[tileId]; const count = playersOnTile.length; const playerIndexOnTile = playersOnTile.indexOf(player.id);
                        let targetLeft = (tileRect.left - boardRect.left) + (tileRect.width / 2) - (player.el.offsetWidth / 2);
                        let targetTop = (tileRect.top - boardRect.top) + (tileRect.height / 2) - (player.el.offsetHeight / 2);
                        if (count > 1) { const angle = (2 * Math.PI / count) * playerIndexOnTile; const radius = playerSize * 0.4; targetLeft += Math.cos(angle) * radius; targetTop += Math.sin(angle) * radius; }
                        player.el.style.left = `${targetLeft}px`; player.el.style.top = `${targetTop}px`;
                    }
                });
            }

            function updateTurnIndicator() {
                const player = gameState.players[gameState.currentPlayerIndex];
                turnIndicator.textContent = `Na tahu je ${player.name}`; turnIndicator.style.color = player.color;
                updateMaliceCardUI();
            }
            
            renderPlayerSetups();
            window.addEventListener('resize', () => { if (gameState.players) { updatePlayerPositions(); } });

            // ================== SQUARE BOARD SIZE CALC ==================
            function resizeBoardToSquares() {
                const container = boardContainer;
                if (!container) return;
                // Base width = full available (within max-width already by CSS)
                const panel = document.getElementById('game-panel');
                const vw = window.innerWidth; const vh = window.innerHeight;
                // Use actual rendered width (might be limited by max-width)
                let width = container.clientWidth || Math.min(vw - 16, 900);
                const desiredHeight = width * (boardConfig.rows / boardConfig.cols);
                const reserved = panel ? panel.offsetHeight + 24 : 220;
                const maxHeight = vh - reserved;
                let height = desiredHeight;
                if (height > maxHeight) {
                    // Scale down width proportionally so height fits
                    const scale = maxHeight / height;
                    width = width * scale;
                    height = maxHeight;
                    container.style.width = width + 'px';
                } else {
                    container.style.width = '';
                }
                container.style.height = height + 'px';
                // After resizing container, reposition players if needed
                if (gameState.players && gameState.players.length) {
                    requestAnimationFrame(() => updatePlayerPositions());
                }
            }
            // Landscape fullscreen variant: base on height if landscape & mobile
            function applyLandscapeFullscreen() {
                const body = document.body;
                const gameContainerHidden = gameContainer.classList.contains('hidden');
                const landscape = window.matchMedia('(orientation: landscape)').matches;
                const mobile = window.innerWidth <= 900 && window.innerHeight <= 600; // heuristic for tablets vs phones
                if (!gameContainerHidden && landscape && mobile) {
                    body.classList.add('landscape-compact');
                    document.documentElement.classList.add('landscape-compact');
                    // Recompute board using available height
                    const panel = document.getElementById('game-panel');
                    const container = boardContainer;
                    if (container) {
                        const vv = window.visualViewport || { width: window.innerWidth, height: window.innerHeight };
                        const vh = vv.height; const vw = vv.width;
                        const collapsed = body.classList.contains('panel-collapsed');
                        // Reset condensed state initially each pass
                        if (!collapsed) panel.classList.remove('panel-condensed');
                        const panelH = collapsed ? 0 : (panel ? panel.offsetHeight : 60);
                        // dynamic top offset (panel height + small gap unless collapsed)
                        container.style.top = (collapsed ? 4 : (panelH + 4)) + 'px';
                        const usableH = vh - (collapsed ? 8 : (panelH + 8)); // bottom gap
                        const usableW = vw - 8; // small horizontal padding
                        // Fit square grid proportionally: width:height = cols:rows
                        let widthCandidate = usableW;
                        let heightNeeded = widthCandidate * (boardConfig.rows / boardConfig.cols);
                        if (heightNeeded > usableH) {
                            heightNeeded = usableH;
                            widthCandidate = heightNeeded * (boardConfig.cols / boardConfig.rows);
                        }
                        // Apply initial size
                        container.style.width = widthCandidate + 'px';
                        container.style.height = heightNeeded + 'px';
                        // Center horizontally
                        container.style.left = ((vw - widthCandidate) / 2) + 'px';
                        container.style.right = 'auto';
                        // If overflowing bottom (due to dynamic browser chrome), scale down once more
                        requestAnimationFrame(() => {
                            const rect = container.getBoundingClientRect();
                            const overflowInitial = rect.bottom - vh;
                            if (overflowInitial > 2) {
                                // First attempt: if not collapsed and not condensed yet, condense panel and retry
                                if (!collapsed && !panel.classList.contains('panel-condensed')) {
                                    panel.classList.add('panel-condensed');
                                    applyLandscapeFullscreen();
                                    return;
                                }
                                // Second attempt: collapse panel if still overflowing
                                if (!collapsed) {
                                    body.classList.add('panel-collapsed');
                                    applyLandscapeFullscreen();
                                    return;
                                }
                                // Final attempt: scale board down
                                const overflow = rect.bottom - vh + 4;
                                const scale = (heightNeeded - overflow) / heightNeeded;
                                if (scale < 1 && scale > 0.4) {
                                    heightNeeded = heightNeeded * scale;
                                    widthCandidate = widthCandidate * scale;
                                    container.style.width = widthCandidate + 'px';
                                    container.style.height = heightNeeded + 'px';
                                    container.style.left = ((vw - widthCandidate) / 2) + 'px';
                                }
                            }
                            if (gameState.players && gameState.players.length) updatePlayerPositions();
                        });
                    }
                } else {
                    body.classList.remove('landscape-compact');
                    document.documentElement.classList.remove('landscape-compact');
                    body.classList.remove('panel-collapsed');
                    document.getElementById('game-panel')?.classList.remove('panel-condensed');
                    fitGameStage();
                }
            }
            // Panel collapse toggle
            const panelToggleBtn = document.getElementById('panel-toggle-btn');
            panelToggleBtn.addEventListener('click', () => {
                document.body.classList.toggle('panel-collapsed');
                // Change icon
                if (document.body.classList.contains('panel-collapsed')) {
                    panelToggleBtn.textContent = '‚¨áÔ∏è';
                } else {
                    panelToggleBtn.textContent = '‚¨ÜÔ∏è';
                }
                // Recompute layout after transition
                setTimeout(() => applyLandscapeFullscreen(), 50);
            });
            // ================== END SQUARE BOARD SIZE CALC ==================
            function fitGameStage() {
                const stage = document.getElementById('game-stage');
                if (!stage) return;
                const gameContainerHidden = gameContainer.classList.contains('hidden');
                const landscape = window.matchMedia('(orientation: landscape)').matches;
                const mobile = window.innerWidth <= 900 && window.innerHeight <= 600;
                if (!gameContainerHidden && landscape && mobile) {
                    stage.style.transformOrigin = 'top center';
                    stage.style.transform = 'none';
                    const vv = window.visualViewport || { height: window.innerHeight };
                    const vh = vv.height;
                    const rect = stage.getBoundingClientRect();
                    if (rect.height > vh) {
                        const scale = Math.max(0.5, Math.min(1, vh / rect.height));
                        stage.style.transform = `scale(${scale})`;
                        stage.style.width = '100%';
                    }
                } else {
                    stage.style.transform = '';
                    stage.style.width = '';
                }
            }
            window.addEventListener('resize', () => fitGameStage(), { passive: true });
            window.addEventListener('orientationchange', () => setTimeout(fitGameStage, 400));
        });
    </script>
</body>
</html>


